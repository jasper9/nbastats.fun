<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beta Live Feed - NBA Stats Fun</title>
    {% if ga_tracking_id %}
    <script async src="https://www.googletagmanager.com/gtag/js?id={{ ga_tracking_id }}"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', '{{ ga_tracking_id }}');
    </script>
    {% endif %}
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='45' fill='%23f85' stroke='%23333' stroke-width='3'/><path d='M50 5 v90 M5 50 h90 M15 20 Q50 50 15 80 M85 20 Q50 50 85 80' fill='none' stroke='%23333' stroke-width='3'/></svg>">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Oswald:wght@400;500;600;700&family=Roboto:wght@400;500;700&display=swap');
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-card: #1c2128;
            --border: #30363d;
            --text-primary: #ffffff;
            --text-secondary: #b0b8c1;
            --text-muted: #6b7280;
            --nuggets-gold: #fec524;
            --nuggets-navy: #0d2240;
            --positive: #34d399;
            --negative: #f87171;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.5;
        }
        /* Navigation */
        nav {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 0 20px;
        }
        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .nav-brand {
            font-family: 'Oswald', sans-serif;
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--nuggets-gold);
            text-decoration: none;
            padding: 15px 0;
        }
        .nav-links {
            display: flex;
            gap: 5px;
        }
        .nav-links a {
            color: var(--text-secondary);
            text-decoration: none;
            padding: 15px 15px;
            font-size: 0.9rem;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }
        .nav-links a:hover { color: var(--text-primary); }
        .nav-links a.active {
            color: var(--nuggets-gold);
            border-bottom-color: var(--nuggets-gold);
        }
        /* Live nav link styling */
        .nav-live {
            position: relative;
        }
        .nav-live:not(.is-live) {
            text-decoration: line-through;
            opacity: 0.5;
        }
        .nav-live.is-live {
            color: #ef4444 !important;
            font-weight: 600;
        }
        .nav-live.is-live::before {
            content: '';
            position: absolute;
            left: 4px;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            background: #ef4444;
            border-radius: 50%;
            animation: pulse-live 1.5s ease-in-out infinite;
        }
        @keyframes pulse-live {
            0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            50% { opacity: 0.8; box-shadow: 0 0 0 6px rgba(239, 68, 68, 0); }
        }
        /* Header */
        header {
            background: linear-gradient(135deg, var(--nuggets-navy) 0%, #1a3a5c 100%);
            text-align: center;
            padding: 12px 20px;
            border-bottom: 3px solid var(--nuggets-gold);
        }
        .page-title {
            font-family: 'Oswald', sans-serif;
            font-size: 1.8rem;
            font-weight: 700;
            text-transform: uppercase;
            color: var(--text-primary);
        }
        .page-subtitle {
            color: var(--nuggets-gold);
            font-size: 0.8rem;
            margin-top: 3px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 15px;
        }
        /* Game Selector */
        .game-selector {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .game-selector label {
            color: var(--text-muted);
            font-size: 0.85rem;
            display: block;
            margin-bottom: 8px;
        }
        .game-selector select {
            width: 100%;
            padding: 12px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 1rem;
            cursor: pointer;
        }
        .game-selector select:focus {
            outline: none;
            border-color: var(--nuggets-gold);
        }
        .game-selector select optgroup {
            font-weight: 600;
            color: var(--nuggets-gold);
            background: var(--bg-secondary);
            padding: 5px 0;
        }
        .game-selector select option {
            font-weight: 400;
            color: var(--text-primary);
            padding: 8px 12px;
        }
        .archive-link {
            float: right;
            color: var(--nuggets-gold);
            text-decoration: none;
            font-size: 0.85rem;
            font-weight: normal;
        }
        .archive-link:hover {
            text-decoration: underline;
        }
        /* Delay selector for TV sync */
        .delay-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border);
        }
        .delay-selector label {
            color: var(--text-muted);
            font-size: 0.8rem;
            white-space: nowrap;
        }
        .delay-selector select {
            padding: 6px 10px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.85rem;
            cursor: pointer;
        }
        .delay-selector select:focus {
            outline: none;
            border-color: var(--nuggets-gold);
        }
        .delay-indicator {
            font-size: 0.75rem;
            color: var(--nuggets-gold);
            padding: 3px 8px;
            background: rgba(254, 197, 36, 0.15);
            border-radius: 4px;
            display: none;
        }
        .delay-indicator.active {
            display: inline-block;
        }
        .delay-indicator .delay-countdown {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }
        /* Scoreboard */
        .scoreboard {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
        }
        .team-score {
            text-align: center;
        }
        .team-logo {
            width: 60px;
            height: 60px;
            object-fit: contain;
            margin-bottom: 5px;
        }
        .team-abbrev {
            font-family: 'Oswald', sans-serif;
            font-size: 1.2rem;
            color: var(--text-secondary);
        }
        .team-points {
            font-family: 'Oswald', sans-serif;
            font-size: 3rem;
            font-weight: 700;
        }
        .game-clock-section {
            text-align: center;
            min-width: 80px;
        }
        .game-quarter {
            font-family: 'Oswald', sans-serif;
            font-size: 1.2rem;
            color: var(--text-secondary);
            text-transform: uppercase;
        }
        .game-clock {
            font-family: 'Oswald', sans-serif;
            font-size: 2rem;
            font-weight: 700;
            color: var(--nuggets-gold);
        }
        .team-info {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 5px;
            font-size: 0.7rem;
        }
        .timeouts {
            display: flex;
            gap: 3px;
            align-items: center;
        }
        .timeout-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--nuggets-gold);
            transition: opacity 0.3s;
        }
        .timeout-dot.used {
            background: var(--text-muted);
            opacity: 0.3;
        }
        .bonus-indicator {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 600;
            display: none;
        }
        .bonus-indicator.active {
            display: inline;
        }
        /* Odds Display */
        .odds-section {
            display: none;
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .odds-section.visible {
            display: block;
        }
        .odds-row {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 25px;
            flex-wrap: wrap;
        }
        .odds-item {
            text-align: center;
        }
        .odds-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        .live-tag {
            background: #ef4444;
            color: white;
            font-size: 0.5rem;
            padding: 1px 4px;
            border-radius: 3px;
            margin-left: 4px;
            animation: pulse-live 2s infinite;
        }
        @keyframes pulse-live {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        .locked-tag {
            background: #6b7280;
            color: white;
            font-size: 0.5rem;
            padding: 1px 4px;
            border-radius: 3px;
            margin-left: 4px;
        }
        .odds-value {
            font-family: 'Oswald', sans-serif;
            font-size: 1.1rem;
            color: var(--text-primary);
        }
        .odds-value .team-abbrev {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-right: 4px;
        }
        .odds-moneyline {
            display: flex;
            gap: 12px;
            justify-content: center;
        }
        .ml-team {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 50px;
        }
        .ml-abbrev {
            font-size: 0.7rem;
            color: var(--text-muted);
        }
        .ml-value {
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
        }
        .ml-value.favorite {
            color: var(--positive);
        }
        .ml-value.underdog {
            color: var(--text-secondary);
        }
        /* Win Probability Bar */
        .prob-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 200px;
        }
        .prob-bar-container {
            width: 100%;
            height: 24px;
            background: var(--bg-card);
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            position: relative;
        }
        .prob-bar {
            height: 100%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Oswald', sans-serif;
            font-size: 0.75rem;
            color: var(--bg-primary);
            font-weight: 600;
            min-width: 40px;
        }
        .prob-bar.away {
            border-radius: 12px 0 0 12px;
        }
        .prob-bar.home {
            border-radius: 0 12px 12px 0;
        }
        .prob-labels {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 4px;
        }
        .prob-label {
            font-family: 'Oswald', sans-serif;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .prob-label .team-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        .odds-vendor-count {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-align: center;
            margin-top: 8px;
        }
        /* Live Roster Section */
        .roster-section {
            display: none;
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        .roster-section.visible {
            display: block;
        }
        .roster-header {
            font-family: 'Oswald', sans-serif;
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .roster-teams {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .roster-team {
            background: var(--bg-card);
            border-radius: 6px;
            padding: 10px;
        }
        .roster-team-header {
            font-family: 'Oswald', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 2px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .roster-team-header .team-score-small {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        .roster-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 200px;
            overflow-y: auto;
        }
        .roster-player {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 0.8rem;
            color: var(--text-secondary);
            transition: all 0.2s;
        }
        .roster-player:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        .roster-player.on-court {
            color: var(--text-primary);
            background: rgba(52, 211, 153, 0.1);
        }
        .roster-player.on-court .player-name {
            font-weight: 500;
        }
        .on-court-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
            flex-shrink: 0;
            transition: all 0.3s;
        }
        .roster-player.on-court .on-court-indicator {
            background: #34d399;
            box-shadow: 0 0 6px rgba(52, 211, 153, 0.6);
            animation: pulse-oncourt 2s ease-in-out infinite;
        }
        @keyframes pulse-oncourt {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(0.9); }
        }
        .player-name {
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .player-stats-mini {
            font-size: 0.7rem;
            color: var(--text-muted);
            white-space: nowrap;
        }
        .player-stats-mini .pts-highlight {
            color: var(--nuggets-gold);
            font-weight: 600;
        }
        .roster-legend {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.65rem;
            color: var(--text-muted);
        }
        .roster-legend .legend-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #34d399;
        }
        @media (max-width: 600px) {
            .roster-teams {
                grid-template-columns: 1fr;
            }
            .roster-list {
                max-height: 150px;
            }
        }
        /* Mini Charts */
        .mini-charts {
            display: none;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        .mini-charts.visible {
            display: grid;
        }
        .mini-chart {
            background: var(--bg-secondary);
            border-radius: 6px;
            padding: 10px;
        }
        .mini-chart-title {
            font-family: 'Oswald', sans-serif;
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }
        .mini-chart-container {
            height: 100px;
            position: relative;
        }
        @media (max-width: 600px) {
            .mini-charts {
                grid-template-columns: 1fr;
            }
            .mini-chart-container {
                height: 80px;
            }
        }
        /* Chat Feed */
        .chat-container {
            background: var(--bg-secondary);
            border-radius: 8px;
            overflow: hidden;
        }
        .chat-header {
            background: var(--bg-card);
            padding: 12px 15px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .chat-stats {
            display: flex;
            gap: 15px;
            font-size: 0.85rem;
        }
        .stat-item {
            color: var(--text-secondary);
            background: var(--bg-secondary);
            padding: 4px 10px;
            border-radius: 4px;
        }
        .stat-item#stat-score {
            color: var(--nuggets-gold);
            font-weight: 600;
        }
        .stat-item#stat-lead-changes {
            color: #f97316;
        }
        .stat-item#stat-viewers {
            color: var(--positive);
        }
        .chat-title {
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .chat-status {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        .chat-status.connected {
            color: var(--positive);
        }
        .chat-feed {
            height: 500px;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        /* Load More History Button */
        .load-more-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            padding: 10px;
            background: linear-gradient(180deg, var(--bg-card), transparent);
            border-radius: 8px;
            margin-bottom: 5px;
        }
        .load-more-btn {
            background: var(--nuggets-navy);
            border: 1px solid var(--nuggets-gold);
            color: var(--nuggets-gold);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .load-more-btn:hover {
            background: var(--nuggets-gold);
            color: var(--nuggets-navy);
        }
        .load-more-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .load-more-btn.loading {
            pointer-events: none;
        }
        .load-more-icon {
            font-size: 1rem;
        }
        .load-more-hint {
            color: var(--text-muted);
            font-size: 0.75rem;
        }
        /* Chat Messages */
        .chat-message {
            display: flex;
            gap: 10px;
            padding: 8px 12px;
            background: var(--bg-card);
            border-radius: 8px;
            animation: slideIn 0.3s ease-out;
            border-left: 3px solid var(--border);
        }
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .chat-message.bot-play_by_play {
            border-left-color: #ffffff;
        }
        .chat-message.bot-stats_nerd {
            border-left-color: #22d3ee;
        }
        .chat-message.bot-odds_shark {
            border-left-color: #34d399;
        }
        .chat-message.bot-hype_man {
            border-left-color: #f97316;
        }
        .chat-message.bot-referee {
            border-left-color: #fbbf24;
            background: linear-gradient(90deg, rgba(251, 191, 36, 0.1), var(--bg-card));
        }
        .chat-message.bot-historian {
            border-left-color: #a855f7;
        }
        .chat-message.bot-ai_commentator {
            border-left-color: #60a5fa;
            background: linear-gradient(90deg, rgba(96, 165, 250, 0.1), var(--bg-card));
        }
        .msg-avatar {
            font-size: 1.5rem;
            flex-shrink: 0;
        }
        .msg-content {
            flex: 1;
            min-width: 0;
        }
        .msg-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        .msg-bot-name {
            font-weight: 600;
            font-size: 0.8rem;
        }
        .msg-bot-name.bot-play_by_play { color: #ffffff; }
        .msg-bot-name.bot-stats_nerd { color: #22d3ee; }
        .msg-bot-name.bot-odds_shark { color: #34d399; }
        .msg-bot-name.bot-hype_man { color: #f97316; }
        .msg-bot-name.bot-referee { color: #fbbf24; }
        .msg-bot-name.bot-historian { color: #a855f7; }
        .msg-bot-name.bot-ai_commentator { color: #60a5fa; }
        .msg-time {
            font-size: 0.7rem;
            color: var(--text-muted);
        }
        .msg-text {
            color: var(--text-primary);
            font-size: 0.9rem;
            line-height: 1.4;
            white-space: pre-line;  /* Preserve line breaks */
        }
        .msg-score {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 4px;
        }
        /* Team colors for messages */
        .team-MIN .msg-avatar { color: #78BE20; }
        .team-CLE .msg-avatar { color: #860038; }
        /* Footer */
        .footer {
            text-align: center;
            padding: 30px;
            color: var(--text-muted);
            font-size: 0.8rem;
            border-top: 1px solid var(--border);
            margin-top: 40px;
        }
        /* Loading */
        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-muted);
        }
        .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid var(--border);
            border-top-color: var(--nuggets-gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        /* Bot Filters */
        .bot-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            margin-top: 15px;
            padding: 12px;
            background: var(--bg-card);
            border-radius: 6px;
        }
        .filter-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-right: 5px;
        }
        .filter-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-muted);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.5;
        }
        .filter-btn:hover {
            border-color: var(--btn-color);
        }
        .filter-btn.active {
            opacity: 1;
            color: var(--text-primary);
            border-color: var(--btn-color);
            background: rgba(255, 255, 255, 0.05);
        }
        .filter-btn .filter-dot {
            width: 8px;
            height: 8px;
            border-radius: 2px;
            background: var(--btn-color);
            transition: opacity 0.2s;
        }
        .filter-btn:not(.active) .filter-dot {
            opacity: 0.3;
        }
        /* Hide filtered messages */
        .chat-message.filtered {
            display: none !important;
        }
        /* Box Score Section */
        .box-score-section {
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-top: 15px;
            overflow: hidden;
            display: none;
        }
        .box-score-section.visible {
            display: block;
        }
        .box-score-header {
            background: var(--bg-card);
            padding: 12px 15px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .box-score-title {
            font-family: 'Oswald', sans-serif;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9rem;
        }
        .team-toggle {
            display: flex;
            gap: 5px;
        }
        .team-toggle-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
        }
        .team-toggle-btn:hover {
            border-color: var(--text-secondary);
        }
        .team-toggle-btn.active {
            background: var(--nuggets-gold);
            border-color: var(--nuggets-gold);
            color: #000;
        }
        .quarter-scores {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 12px 15px;
            margin-bottom: 15px;
        }
        .quarter-scores-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            border: 1px solid var(--border);
        }
        .quarter-scores-table th,
        .quarter-scores-table td {
            padding: 8px 12px;
            text-align: center;
            border: 1px solid var(--border);
        }
        .quarter-scores-table th {
            color: var(--text-muted);
            font-weight: 500;
            font-size: 0.75rem;
            background: var(--bg-card);
        }
        .quarter-scores-table th:first-child,
        .quarter-scores-table td:first-child {
            text-align: left;
            font-weight: 600;
        }
        .quarter-scores-table td {
            color: var(--text-secondary);
        }
        .quarter-scores-table td.total-col {
            color: var(--text-primary);
            font-weight: 700;
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            background: var(--bg-card);
        }
        .quarter-scores-table td.current-quarter {
            background: rgba(254, 197, 36, 0.15);
        }
        .quarter-scores-table td.quarter-winner {
            color: var(--positive);
            font-weight: 600;
        }
        .quarter-scores-table td.current-winner {
            color: var(--nuggets-gold);
            font-weight: 600;
            background: rgba(254, 197, 36, 0.15);
        }
        .quarter-scores-table tr.winner td.total-col {
            color: var(--positive);
        }
        .box-score-content {
            padding: 10px;
            overflow-x: auto;
        }
        .player-stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }
        .player-stats-table th {
            background: var(--bg-card);
            color: var(--text-secondary);
            font-weight: 500;
            padding: 8px 6px;
            text-align: center;
            border-bottom: 1px solid var(--border);
            white-space: nowrap;
            position: sticky;
            top: 0;
        }
        .player-stats-table th.player-col,
        .player-stats-table td.player-col {
            text-align: left;
            padding-left: 10px;
            min-width: 100px;
            position: sticky;
            left: 0;
            background: var(--bg-card);
            z-index: 1;
        }
        .player-stats-table td.player-col {
            background: var(--bg-secondary);
        }
        .player-stats-table tr:hover td.player-col {
            background: rgba(255,255,255,0.06);
        }
        .player-stats-table tr.totals-row td.player-col {
            background: var(--bg-card);
        }
        .player-stats-table td {
            padding: 8px 6px;
            text-align: center;
            border-bottom: 1px solid var(--border);
            color: var(--text-secondary);
        }
        .player-stats-table td.player-col {
            color: var(--text-primary);
            font-weight: 500;
        }
        /* On-court indicator in player stats table */
        .player-stats-table .on-court-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
            margin-right: 6px;
            vertical-align: middle;
            flex-shrink: 0;
        }
        .player-stats-table .on-court-dot.active {
            background: #34d399;
            box-shadow: 0 0 6px rgba(52, 211, 153, 0.6);
            animation: pulse-oncourt 2s ease-in-out infinite;
        }
        .player-stats-table tr:hover {
            background: rgba(255,255,255,0.03);
        }
        .player-stats-table tr.totals-row {
            background: var(--bg-card);
        }
        .player-stats-table tr.totals-row td {
            font-weight: 600;
            color: var(--text-primary);
            border-top: 2px solid var(--border);
        }
        .player-stats-table .highlight {
            color: var(--nuggets-gold);
            font-weight: 600;
        }
        .player-stats-table .positive {
            color: var(--positive);
        }
        .player-stats-table .negative {
            color: var(--negative);
        }
        .player-stats-table .pct {
            color: var(--text-muted);
            font-size: 0.75rem;
        }
        .player-stats-table tr.section-header td {
            background: var(--bg-card);
            color: var(--text-muted);
            font-weight: 600;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 6px 10px;
            border-bottom: 1px solid var(--border);
            border-top: 1px solid var(--border);
        }
        .player-stats-table tr.section-header:hover {
            background: var(--bg-card);
        }
        @media (max-width: 600px) {
            .page-title { font-size: 1.4rem; }
            .chat-feed { height: 400px; }
            .scoreboard { gap: 15px; }
            .team-logo { width: 45px; height: 45px; }
            .team-points { font-size: 2.5rem; }
            .nav-links a { padding: 15px 10px; font-size: 0.8rem; }
        }
    </style>
</head>
<body>
    <nav>
        <div class="nav-container">
            <a href="/" class="nav-brand">NBA Stats . Fun</a>
            <div class="nav-links">
                <a href="/">Home</a>
                <a href="/jokic">Jokic</a>
                <a href="/more">Nuggets</a>
                <a href="/live" class="nav-live {{ 'is-live' if is_game_live else '' }}">Live</a>
                <a href="/beta-live" class="active" style="color: #f97316;">Beta</a>
            </div>
        </div>
    </nav>

    <header>
        <div class="page-title">Live Play-by-Play Feed <span style="background: #f97316; color: white; font-size: 0.5em; padding: 3px 8px; border-radius: 4px; vertical-align: middle; margin-left: 10px;">BETA</span></div>
        <div class="page-subtitle">Real-time game updates with personality</div>
    </header>

    <div class="container">
        <div class="game-selector">
            <label>
                Select a live game: <span id="timezone-label" style="font-weight: normal; opacity: 0.7;"></span>
                <a href="/beta-live/archive" class="archive-link">View Past Games</a>
            </label>
            <select id="game-select">
                <option value="">Loading games...</option>
            </select>
            <div class="delay-selector" id="delay-selector" style="display: none;">
                <label for="delay-select">üì∫ TV Sync Delay:</label>
                <select id="delay-select">
                    <option value="0">No delay (live)</option>
                    <option value="15">15 seconds</option>
                    <option value="30">30 seconds</option>
                    <option value="45">45 seconds</option>
                    <option value="60">1 minute</option>
                    <option value="90">1.5 minutes</option>
                    <option value="120">2 minutes</option>
                </select>
                <span class="delay-indicator" id="delay-indicator">
                    Delayed by <span class="delay-countdown" id="delay-countdown">0s</span>
                </span>
            </div>
        </div>

        <div class="scoreboard" id="scoreboard" style="display: none;">
            <div class="team-score">
                <img class="team-logo" id="away-logo" src="" alt="Away team logo">
                <div class="team-abbrev" id="away-team">AWAY</div>
                <div class="team-points" id="away-score">0</div>
                <div class="team-info">
                    <span class="timeouts" id="away-timeouts" title="Timeouts remaining"></span>
                    <span class="bonus-indicator" id="away-bonus" title="In bonus">BONUS</span>
                </div>
            </div>
            <div class="game-clock-section" id="game-clock-section">
                <div class="game-quarter" id="game-quarter">Q1</div>
                <div class="game-clock" id="game-clock">12:00</div>
            </div>
            <div class="team-score">
                <img class="team-logo" id="home-logo" src="" alt="Home team logo">
                <div class="team-abbrev" id="home-team">HOME</div>
                <div class="team-points" id="home-score">0</div>
                <div class="team-info">
                    <span class="timeouts" id="home-timeouts" title="Timeouts remaining"></span>
                    <span class="bonus-indicator" id="home-bonus" title="In bonus">BONUS</span>
                </div>
            </div>
        </div>

        <div class="odds-section" id="odds-section">
            <div class="odds-row">
                <div class="odds-item">
                    <div class="odds-label">Spread <span class="live-tag">LIVE</span></div>
                    <div class="odds-value" id="odds-spread">--</div>
                </div>
                <div class="odds-item">
                    <div class="odds-label">Total <span class="live-tag">LIVE</span></div>
                    <div class="odds-value" id="odds-total">--</div>
                </div>
                <div class="odds-item">
                    <div class="odds-label">Moneyline <span class="live-tag">LIVE</span></div>
                    <div class="odds-moneyline" id="odds-moneyline">
                        <div class="ml-team">
                            <span class="ml-abbrev" id="ml-away-abbrev">AWAY</span>
                            <span class="ml-value" id="ml-away-value">--</span>
                        </div>
                        <div class="ml-team">
                            <span class="ml-abbrev" id="ml-home-abbrev">HOME</span>
                            <span class="ml-value" id="ml-home-value">--</span>
                        </div>
                    </div>
                </div>
                <div class="odds-item prob-display">
                    <div class="odds-label">Pre-Game Odds <span class="locked-tag">LOCKED</span></div>
                    <div class="prob-bar-container">
                        <div class="prob-bar away" id="away-prob-bar"></div>
                        <div class="prob-bar home" id="home-prob-bar"></div>
                    </div>
                    <div class="prob-labels">
                        <span class="prob-label" id="away-prob-label">
                            <span class="team-dot" id="away-dot"></span>
                            <span id="away-prob-text">AWAY 50%</span>
                        </span>
                        <span class="prob-label" id="home-prob-label">
                            <span id="home-prob-text">HOME 50%</span>
                            <span class="team-dot" id="home-dot"></span>
                        </span>
                    </div>
                </div>
            </div>
            <div class="odds-vendor-count" id="odds-vendor-count"></div>
        </div>

        <div class="mini-charts" id="mini-charts">
            <div class="mini-chart">
                <div class="mini-chart-title">Lead Differential</div>
                <div class="mini-chart-container">
                    <canvas id="leadChart"></canvas>
                </div>
            </div>
            <div class="mini-chart">
                <div class="mini-chart-title">Live Win Probability</div>
                <div class="mini-chart-container">
                    <canvas id="probChart"></canvas>
                </div>
            </div>
        </div>

        <div class="quarter-scores" id="quarter-scores" style="display: none;">
            <table class="quarter-scores-table">
                <thead>
                    <tr>
                        <th>Team</th>
                        <th>Q1</th>
                        <th>Q2</th>
                        <th>Q3</th>
                        <th>Q4</th>
                        <th class="ot-col" style="display:none;">OT</th>
                        <th>Total</th>
                    </tr>
                </thead>
                <tbody id="quarter-scores-body">
                </tbody>
            </table>
        </div>

        <div class="chat-container" id="chat-container" style="display: none;">
            <div class="chat-header">
                <span class="chat-title">Live Feed</span>
                <div class="chat-stats">
                    <span class="stat-item" id="stat-score">0-0</span>
                    <span class="stat-item" id="stat-lead-changes">üîÑ 0</span>
                    <span class="stat-item" id="stat-viewers">üëÅ 1</span>
                </div>
            </div>
            <div class="chat-feed" id="chat-feed">
                <div class="load-more-container" id="load-more-container" style="display: none;">
                    <button class="load-more-btn" id="load-more-btn">
                        <span class="load-more-icon">‚èÆ</span>
                        Load Full Game History
                    </button>
                    <span class="load-more-hint">Showing recent plays only</span>
                </div>
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <p>Waiting for game updates...</p>
                </div>
            </div>
        </div>

        <div class="bot-filters">
            <span class="filter-label">Filter voices:</span>
            <button class="filter-btn active" data-bot="play_by_play" style="--btn-color: #ffffff;">
                <span class="filter-dot"></span>
                PlayByPlay
            </button>
            <button class="filter-btn active" data-bot="stats_nerd" style="--btn-color: #22d3ee;">
                <span class="filter-dot"></span>
                StatsNerd
            </button>
            <button class="filter-btn active" data-bot="hype_man" style="--btn-color: #f97316;">
                <span class="filter-dot"></span>
                HypeMan
            </button>
            <button class="filter-btn active" data-bot="referee" style="--btn-color: #fbbf24;">
                <span class="filter-dot"></span>
                Referee
            </button>
            <button class="filter-btn active" data-bot="historian" style="--btn-color: #a855f7;">
                <span class="filter-dot"></span>
                Historian
            </button>
            <button class="filter-btn active" data-bot="ai_commentator" style="--btn-color: #60a5fa;">
                <span class="filter-dot"></span>
                AI
            </button>
        </div>

        <!-- Box Score Section -->
        <div class="box-score-section" id="box-score-section">
            <div class="box-score-header">
                <span class="box-score-title">Box Score</span>
                <div class="team-toggle">
                    <button class="team-toggle-btn active" id="toggle-away" data-team="away">Away</button>
                    <button class="team-toggle-btn" id="toggle-home" data-team="home">Home</button>
                </div>
            </div>
            <div class="box-score-content">
                <table class="player-stats-table">
                    <thead>
                        <tr>
                            <th class="player-col">Player</th>
                            <th>MIN</th>
                            <th>PTS</th>
                            <th>REB</th>
                            <th>AST</th>
                            <th>STL</th>
                            <th>BLK</th>
                            <th>FGM</th>
                            <th>FGA</th>
                            <th>FG%</th>
                            <th>3PM</th>
                            <th>3PA</th>
                            <th>3P%</th>
                            <th>FTM</th>
                            <th>FTA</th>
                            <th>FT%</th>
                            <th>OREB</th>
                            <th>DREB</th>
                            <th>TOV</th>
                            <th>PF</th>
                            <th>+/-</th>
                        </tr>
                    </thead>
                    <tbody id="player-stats-body">
                        <!-- Player rows will be inserted here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <div class="footer">
        <p>Beta feature - Live play-by-play from NBA API</p>
    </div>

    <script>
        // ============================================================
        // FEATURE FLAG: TV Sync Delay
        // Set to false to completely disable the delay feature
        // ============================================================
        const DELAY_FEATURE_ENABLED = true;

        // Delay buffer for TV sync (client-side only)
        let delaySeconds = 0;  // Current delay in seconds
        let delayBuffer = [];  // Buffer of {data, receivedAt} objects
        let delayDisplayInterval = null;  // Interval for processing delayed display
        let lastDisplayedScore = { home: 0, away: 0 };
        let lastDisplayedClock = { period: 0, clock: '' };

        // Bot emoji mapping
        const botEmojis = {
            'play_by_play': '&#x1F3C0;',
            'stats_nerd': '&#x1F4CA;',
            'odds_shark': '&#x1F3B0;',
            'hype_man': '&#x1F525;',
            'referee': '&#x1F6A8;',  // Police light/siren for ref calls
            'historian': '&#x1F4DC;',
            'ai_commentator': '&#x1F916;'
        };

        const botNames = {
            'play_by_play': 'PlayByPlay',
            'stats_nerd': 'StatsNerd',
            'odds_shark': 'OddsShark',
            'hype_man': 'HypeMan',
            'referee': 'Referee',
            'historian': 'Historian',
            'ai_commentator': 'AI'
        };

        // NBA team ID mapping for logos (abbreviation -> NBA team ID)
        const teamIds = {
            'ATL': 1610612737, 'BOS': 1610612738, 'BKN': 1610612751, 'CHA': 1610612766,
            'CHI': 1610612741, 'CLE': 1610612739, 'DAL': 1610612742, 'DEN': 1610612743,
            'DET': 1610612765, 'GSW': 1610612744, 'HOU': 1610612745, 'IND': 1610612754,
            'LAC': 1610612746, 'LAL': 1610612747, 'MEM': 1610612763, 'MIA': 1610612748,
            'MIL': 1610612749, 'MIN': 1610612750, 'NOP': 1610612740, 'NYK': 1610612752,
            'OKC': 1610612760, 'ORL': 1610612753, 'PHI': 1610612755, 'PHX': 1610612756,
            'POR': 1610612757, 'SAC': 1610612758, 'SAS': 1610612759, 'TOR': 1610612761,
            'UTA': 1610612762, 'WAS': 1610612764
        };

        // Get team logo URL from abbreviation
        function getTeamLogoUrl(abbrev) {
            const teamId = teamIds[abbrev];
            if (teamId) {
                return `https://cdn.nba.com/logos/nba/${teamId}/primary/L/logo.svg`;
            }
            return '';
        }

        let currentGameId = null;
        let lastActionNumber = 0;
        let pollInterval = null;
        let clientId = 'client_' + Math.random().toString(36).substr(2, 9);

        // Countdown timer for pregame
        let countdownInterval = null;
        let scheduledTimeUtc = null;
        let gameHasStarted = false;

        // Current team names for chart labels
        let currentHomeTeam = 'HOME';
        let currentAwayTeam = 'AWAY';

        // Chart instances and data
        let leadChart = null;
        let probChart = null;
        let chartData = {
            labels: [],
            homeScores: [],
            awayScores: [],
            leadDiffs: [],  // positive = home leading
            homeProbs: [],  // home team win probability (0-100)
            quarterMarkers: [],  // indices where quarters start
            quarterLabels: []    // labels for quarter markers (Q1, Q2, etc.)
        };
        let lastPeriod = 0;  // Track current period for quarter markers
        let scoreHistoryLoaded = false;  // Track if we've loaded score history (to prevent duplicates)

        // Player stats data
        let playerStats = { home: [], away: [] };
        let currentStatsTeam = 'away';  // Currently displayed team

        // History loading state
        let hasMoreHistory = false;
        let historyCutoffAction = 0;
        let isLoadingFullHistory = false;

        // On-court player tracking
        // Tracks players mentioned in recent plays to infer who's on court
        let onCourtPlayers = { home: new Set(), away: new Set() };
        const RECENT_PLAYS_WINDOW = 8;  // Number of recent plays to consider
        let recentPlayPlayers = [];  // Array of {player, team, timestamp}

        // Custom Chart.js plugin to draw vertical quarter lines (at data index positions)
        const quarterLinesPlugin = {
            id: 'quarterLines',
            afterDraw: (chart) => {
                const ctx = chart.ctx;
                const xAxis = chart.scales.x;
                const yAxis = chart.scales.y;

                if (!chartData.quarterMarkers.length) return;

                ctx.save();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);

                chartData.quarterMarkers.forEach((dataIndex, i) => {
                    // quarterMarkers stores the data index where each quarter starts
                    const x = xAxis.getPixelForValue(dataIndex);

                    ctx.beginPath();
                    ctx.moveTo(x, yAxis.top);
                    ctx.lineTo(x, yAxis.bottom);
                    ctx.stroke();

                    // Draw quarter label at top
                    if (chartData.quarterLabels[i]) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.font = '8px Oswald';
                        ctx.textAlign = 'center';
                        ctx.fillText(chartData.quarterLabels[i], x, yAxis.top - 2);
                    }
                });

                ctx.restore();
            }
        };

        // Register the plugin globally
        Chart.register(quarterLinesPlugin);

        // Current game odds (updates during game)
        let currentOdds = null;

        // Pre-game odds (locked at first load, never changes)
        let preGameOdds = null;
        let preGameOddsLocked = false;

        // Store games for accessing odds when selecting
        let gamesData = {};

        // NBA team colors (primary and secondary)
        const teamColors = {
            'MIN': '#78BE20', 'CLE': '#860038', 'BOS': '#007A33', 'MIA': '#98002E',
            'IND': '#002D62', 'LAC': '#C8102E', 'DET': '#C8102E', 'SAS': '#C4CED4',
            'DAL': '#00538C', 'CHI': '#CE1141', 'CHA': '#1D1160', 'UTA': '#002B5C',
            'DEN': '#FEC524', 'LAL': '#552583', 'GSW': '#1D428A', 'PHX': '#E56020',
            'ATL': '#E03A3E', 'BKN': '#FFFFFF', 'HOU': '#CE1141', 'MEM': '#5D76A9',
            'MIL': '#00471B', 'NOP': '#C8102E', 'NYK': '#F58426', 'OKC': '#007AC1',
            'ORL': '#0077C0', 'PHI': '#006BB6', 'POR': '#E03A3E', 'SAC': '#5A2D81',
            'TOR': '#CE1141', 'WAS': '#002B5C'
        };

        // Secondary colors for when primary colors are too similar
        const teamColorsAlt = {
            'MIN': '#0C2340', 'CLE': '#FDBB30', 'BOS': '#BA9653', 'MIA': '#F9A01B',
            'IND': '#FDBB30', 'LAC': '#1D428A', 'DET': '#1D42BA', 'SAS': '#000000',
            'DAL': '#B8C4CA', 'CHI': '#000000', 'CHA': '#00788C', 'UTA': '#F9A01B',
            'DEN': '#0E2240', 'LAL': '#FDB927', 'GSW': '#FFC72C', 'PHX': '#1D1160',
            'ATL': '#C1D32F', 'BKN': '#000000', 'HOU': '#C4CED4', 'MEM': '#12173F',
            'MIL': '#EEE1C6', 'NOP': '#0C2340', 'NYK': '#006BB6', 'OKC': '#EF3B24',
            'ORL': '#000000', 'PHI': '#ED174C', 'POR': '#000000', 'SAC': '#63727A',
            'TOR': '#000000', 'WAS': '#E31837'
        };

        // Check if two colors are too similar
        function colorDistance(hex1, hex2) {
            const r1 = parseInt(hex1.slice(1,3), 16);
            const g1 = parseInt(hex1.slice(3,5), 16);
            const b1 = parseInt(hex1.slice(5,7), 16);
            const r2 = parseInt(hex2.slice(1,3), 16);
            const g2 = parseInt(hex2.slice(3,5), 16);
            const b2 = parseInt(hex2.slice(5,7), 16);
            return Math.sqrt((r2-r1)**2 + (g2-g1)**2 + (b2-b1)**2);
        }

        // Check if a color is dark (for text contrast)
        function isColorDark(hex) {
            const r = parseInt(hex.slice(1,3), 16);
            const g = parseInt(hex.slice(3,5), 16);
            const b = parseInt(hex.slice(5,7), 16);
            // Using relative luminance formula
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance < 0.5;
        }

        // Get team colors, ensuring they're different enough
        function getTeamColors(awayTeam, homeTeam) {
            let awayColor = teamColors[awayTeam] || '#ef4444';
            let homeColor = teamColors[homeTeam] || '#fec524';

            // If colors are too similar (distance < 80), use alternate for away team
            if (colorDistance(awayColor, homeColor) < 80) {
                awayColor = teamColorsAlt[awayTeam] || '#ef4444';
            }

            // If still too similar, use alternate for home team too
            if (colorDistance(awayColor, homeColor) < 80) {
                homeColor = teamColorsAlt[homeTeam] || '#fec524';
            }

            return { awayColor, homeColor };
        }

        // Helper to convert elapsed seconds to game time string (e.g., "Q2 5:32")
        function elapsedToGameTime(elapsed) {
            if (elapsed === null || elapsed === undefined) return '';
            const period = Math.floor(elapsed / 720) + 1;
            const periodElapsed = elapsed % 720;
            const remaining = 720 - periodElapsed;
            const mins = Math.floor(remaining / 60);
            const secs = remaining % 60;
            const qLabel = period <= 4 ? `Q${period}` : `OT${period - 4}`;
            return `${qLabel} ${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function initCharts() {
            // Destroy existing charts
            if (leadChart) { leadChart.destroy(); leadChart = null; }
            if (probChart) { probChart.destroy(); probChart = null; }

            // Reset data including quarter markers and elapsed times
            chartData = { labels: [], elapsed: [], clocks: [], homeScores: [], awayScores: [], leadDiffs: [], homeProbs: [], quarterMarkers: [], quarterLabels: [] };
            lastPeriod = 0;

            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                animation: { duration: 0 },
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        enabled: true,
                        backgroundColor: 'rgba(13, 17, 23, 0.9)',
                        titleColor: '#fec524',
                        bodyColor: '#ffffff',
                        borderColor: '#30363d',
                        borderWidth: 1,
                        padding: 8,
                        displayColors: false,
                        titleFont: { family: 'Oswald', size: 11 },
                        bodyFont: { family: 'Roboto', size: 11 }
                    }
                },
                scales: {
                    x: {
                        display: false
                        // Uses default category scale with sequential indices
                    },
                    y: {
                        ticks: {
                            font: { size: 9 },
                            color: '#6b7280',
                            maxTicksLimit: 5
                        },
                        grid: { color: 'rgba(255,255,255,0.1)' }
                    }
                }
            };

            // Lead Differential Chart (simple y values, index is implicit x-axis)
            const leadCtx = document.getElementById('leadChart').getContext('2d');
            leadChart = new Chart(leadCtx, {
                type: 'line',
                data: {
                    datasets: [{
                        data: [],  // Will be populated with y values
                        borderColor: '#fec524',
                        borderWidth: 1.5,
                        fill: {
                            target: { value: 0 },
                            above: 'rgba(134, 0, 56, 0.3)',  // home color
                            below: 'rgba(120, 190, 32, 0.3)'  // away color
                        },
                        tension: 0.2,
                        pointRadius: 0,
                        pointHoverRadius: 4,
                        pointHoverBackgroundColor: '#fec524'
                    }]
                },
                options: {
                    ...chartOptions,
                    plugins: {
                        ...chartOptions.plugins,
                        tooltip: {
                            ...chartOptions.plugins.tooltip,
                            callbacks: {
                                title: (items) => {
                                    const idx = items[0]?.dataIndex;
                                    if (idx === undefined) return '';
                                    const elapsed = chartData.elapsed[idx];
                                    const gameTime = elapsedToGameTime(elapsed);
                                    const home = chartData.homeScores[idx] || 0;
                                    const away = chartData.awayScores[idx] || 0;
                                    return `${gameTime} | ${away} - ${home}`;
                                },
                                label: (ctx) => {
                                    const val = ctx.parsed.y;
                                    if (val === 0) return 'Tied';
                                    return val > 0 ? `${currentHomeTeam} +${val}` : `${currentAwayTeam} +${Math.abs(val)}`;
                                }
                            }
                        },
                        annotation: {
                            annotations: {}  // Will be populated with max lead lines
                        }
                    },
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            suggestedMin: -15,
                            suggestedMax: 15,
                            ticks: {
                                ...chartOptions.scales.y.ticks,
                                stepSize: 5,
                                callback: v => v > 0 ? `+${Math.round(v)}` : Math.round(v)
                            },
                            grid: {
                                color: ctx => ctx.tick.value === 0 ? 'rgba(255,255,255,0.4)' : 'rgba(255,255,255,0.1)'
                            }
                        }
                    }
                }
            });

            // Win Probability Chart (simple y values, index is implicit x-axis)
            const probCtx = document.getElementById('probChart').getContext('2d');
            probChart = new Chart(probCtx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Win Prob',
                        data: [],  // Will be populated with y values
                        borderColor: '#fec524',
                        borderWidth: 1.5,
                        fill: {
                            target: { value: 0 },
                            above: 'rgba(254, 197, 36, 0.3)',  // home favored (gold)
                            below: 'rgba(239, 68, 68, 0.3)'   // away favored (red)
                        },
                        tension: 0.2,
                        pointRadius: 0,
                        pointHoverRadius: 4,
                        pointHoverBackgroundColor: '#fec524'
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            min: -100,
                            max: 100,
                            ticks: {
                                font: { size: 8 },
                                color: '#6b7280',
                                stepSize: 50,
                                callback: v => {
                                    if (v === 100) return currentHomeTeam;
                                    if (v === 0) return 'EVEN';
                                    if (v === -100) return currentAwayTeam;
                                    return '';
                                }
                            },
                            grid: {
                                color: ctx => ctx.tick.value === 0 ? 'rgba(255,255,255,0.4)' : 'rgba(255,255,255,0.1)'
                            }
                        }
                    },
                    plugins: {
                        ...chartOptions.plugins,
                        tooltip: {
                            ...chartOptions.plugins.tooltip,
                            callbacks: {
                                title: (items) => {
                                    const idx = items[0]?.dataIndex;
                                    if (idx === undefined) return '';
                                    const elapsed = chartData.elapsed[idx];
                                    const gameTime = elapsedToGameTime(elapsed);
                                    const home = chartData.homeScores[idx] || 0;
                                    const away = chartData.awayScores[idx] || 0;
                                    return `${gameTime} | ${away} - ${home}`;
                                },
                                label: (ctx) => {
                                    // Convert swing value back to probability
                                    const swingVal = ctx.parsed.y;
                                    const homeProb = Math.round(50 + swingVal / 2);
                                    const awayProb = 100 - homeProb;
                                    return `${currentHomeTeam} ${homeProb}% | ${currentAwayTeam} ${awayProb}%`;
                                }
                            }
                        }
                    }
                }
            });

            // Show charts
            document.getElementById('mini-charts').classList.add('visible');
        }

        // Estimate win probability based on score and game progress
        // Uses pre-game odds as baseline, then adjusts based on score differential
        function estimateWinProbability(homeScore, awayScore, period) {
            const lead = homeScore - awayScore;

            // Get baseline probability from pre-game odds (locked at first load)
            let baseProb = 50;
            if (preGameOdds && preGameOdds.consensus) {
                const homeProb = preGameOdds.consensus.home_prob || 50;
                const awayProb = preGameOdds.consensus.away_prob || 50;
                // Normalize to remove vig
                const totalProb = homeProb + awayProb;
                baseProb = (homeProb / totalProb) * 100;
            }

            // If game hasn't started (no score), return pre-game odds
            if (homeScore === 0 && awayScore === 0 && (!period || period === 0)) {
                return baseProb;
            }

            // Estimate game progress (0-1 scale based on period)
            let gameProgress = 0.25;  // Default to early game
            if (period) {
                if (period <= 4) {
                    gameProgress = period / 4;  // Q1=0.25, Q2=0.5, Q3=0.75, Q4=1.0
                } else {
                    gameProgress = 1.0;  // Overtime
                }
            }

            // Each point shifts probability more as game progresses
            // Early game: ~1.5% per point, Late game: ~4% per point
            const pointValue = 1.5 + gameProgress * 2.5;
            let probAdjust = lead * pointValue;

            // Cap adjustment to keep probability in reasonable range
            probAdjust = Math.max(-40, Math.min(40, probAdjust));

            // Apply adjustment to baseline (pre-game odds), not 50%
            let finalProb = baseProb + probAdjust;

            // Clamp to valid probability range
            return Math.max(5, Math.min(95, finalProb));
        }

        function updateCharts(homeScore, awayScore, homeTeam, awayTeam, homeProb = null, period = null, elapsed = null, clock = null) {
            if (!leadChart || !probChart) return;

            // Calculate elapsed time if not provided (for backwards compatibility)
            if (elapsed === null && period) {
                // Default to start of current period if no elapsed given
                elapsed = (period - 1) * 720;
            } else if (elapsed === null) {
                // Fallback: use index * some interval
                elapsed = chartData.elapsed.length * 30;
            }

            // Check for quarter change - add marker at current index
            if (period && period > lastPeriod) {
                // Store the index where this quarter starts (for vertical line positioning)
                chartData.quarterMarkers.push(chartData.labels.length);
                chartData.quarterLabels.push(period <= 4 ? `Q${period}` : `OT${period - 4}`);
                lastPeriod = period;
            }

            // Add data point using sequential index for x-axis (elapsed kept for tooltip display)
            const idx = chartData.labels.length;
            chartData.labels.push(idx);
            chartData.elapsed.push(elapsed);  // Keep for tooltip game time display
            chartData.clocks.push(clock || '');
            chartData.homeScores.push(homeScore);
            chartData.awayScores.push(awayScore);

            const leadDiff = homeScore - awayScore;
            chartData.leadDiffs.push(leadDiff);  // Simple y-value, index is implicit

            // Add probability data point (convert to swing scale: 50% ‚Üí 0, 100% ‚Üí +100, 0% ‚Üí -100)
            let prob;
            if (homeProb !== null) {
                prob = homeProb;
            } else {
                // Estimate win probability based on score differential and game progress
                prob = estimateWinProbability(homeScore, awayScore, period);
            }
            const swingValue = (prob - 50) * 2;  // 50% ‚Üí 0, 75% ‚Üí +50, 25% ‚Üí -50
            chartData.homeProbs.push(swingValue);  // Simple y-value, index is implicit

            // Update team colors in charts (use contrasting colors)
            const { awayColor, homeColor } = getTeamColors(awayTeam, homeTeam);

            // Update lead chart fill colors
            leadChart.data.datasets[0].fill.above = homeColor + '4D';  // 30% opacity
            leadChart.data.datasets[0].fill.below = awayColor + '4D';

            // Update chart data (simple arrays, index is implicit x-axis)
            leadChart.data.labels = chartData.labels;
            leadChart.data.datasets[0].data = chartData.leadDiffs;
            probChart.data.labels = chartData.labels;
            probChart.data.datasets[0].data = chartData.homeProbs;

            // Update max lead annotations
            updateMaxLeadAnnotations();

            // Update chart display
            leadChart.update('none');
            probChart.update('none');
        }

        // Update max lead annotations on the Lead Differential chart
        function updateMaxLeadAnnotations() {
            if (!leadChart || chartData.leadDiffs.length < 2) return;

            const diffs = chartData.leadDiffs;
            let maxHomeLead = 0, maxHomeLeadIdx = -1;
            let maxAwayLead = 0, maxAwayLeadIdx = -1;

            // Find max leads (positive = home leading, negative = away leading)
            for (let i = 0; i < diffs.length; i++) {
                const diff = diffs[i];
                if (diff > maxHomeLead) {
                    maxHomeLead = diff;
                    maxHomeLeadIdx = i;
                }
                if (diff < -maxAwayLead) {
                    maxAwayLead = -diff;
                    maxAwayLeadIdx = i;
                }
            }

            const annotations = {};
            const lastIdx = diffs.length - 1;
            const currentDiff = diffs[lastIdx];

            // Get team colors
            const { awayColor, homeColor } = getTeamColors(currentAwayTeam, currentHomeTeam);

            // Max home team lead annotation (positive lead)
            if (maxHomeLeadIdx >= 0 && maxHomeLead > 0) {
                const isCurrent = maxHomeLeadIdx === lastIdx && currentDiff > 0;
                const label = isCurrent
                    ? `MAX +${maxHomeLead}`
                    : `MAX +${maxHomeLead} ${currentHomeTeam}`;
                // Use dark text on light backgrounds for readability
                const homeTextColor = isColorDark(homeColor) ? '#ffffff' : '#0d1117';

                annotations.maxHomeLead = {
                    type: 'line',
                    xMin: maxHomeLeadIdx,
                    xMax: maxHomeLeadIdx,
                    yMin: 0,
                    yMax: maxHomeLead,
                    borderColor: homeColor,
                    borderWidth: 2,
                    label: {
                        display: true,
                        content: label,
                        position: 'end',
                        backgroundColor: homeColor,
                        color: homeTextColor,
                        font: { size: 9, weight: 'bold', family: 'Oswald' },
                        padding: 3,
                        yAdjust: -8
                    }
                };
            }

            // Max away team lead annotation (negative lead)
            if (maxAwayLeadIdx >= 0 && maxAwayLead > 0) {
                const isCurrent = maxAwayLeadIdx === lastIdx && currentDiff < 0;
                const label = isCurrent
                    ? `MAX +${maxAwayLead}`
                    : `MAX +${maxAwayLead} ${currentAwayTeam}`;
                // Use dark text on light backgrounds for readability
                const awayTextColor = isColorDark(awayColor) ? '#ffffff' : '#0d1117';

                annotations.maxAwayLead = {
                    type: 'line',
                    xMin: maxAwayLeadIdx,
                    xMax: maxAwayLeadIdx,
                    yMin: -maxAwayLead,
                    yMax: 0,
                    borderColor: awayColor,
                    borderWidth: 2,
                    label: {
                        display: true,
                        content: label,
                        position: 'start',
                        backgroundColor: awayColor,
                        color: awayTextColor,
                        font: { size: 9, weight: 'bold', family: 'Oswald' },
                        padding: 3,
                        yAdjust: 8
                    }
                };
            }

            // Update chart annotations
            leadChart.options.plugins.annotation.annotations = annotations;
        }

        function formatMoneyline(ml) {
            if (ml === null || ml === undefined) return '--';
            return ml > 0 ? `+${ml}` : ml.toString();
        }

        // Render timeout dots (7 total: lit for remaining, dim for used)
        function renderTimeoutDots(container, remaining) {
            const total = 7;
            const used = total - remaining;
            let html = '';
            // Show remaining (lit) dots first, then used (dim) dots
            for (let i = 0; i < remaining; i++) {
                html += '<span class="timeout-dot"></span>';
            }
            for (let i = 0; i < used; i++) {
                html += '<span class="timeout-dot used"></span>';
            }
            container.innerHTML = html;
        }

        function updateOddsDisplay(odds, homeTeam, awayTeam, homeCity = null, awayCity = null, fixedPreGameOdds = null) {
            const oddsSection = document.getElementById('odds-section');
            if (!odds || !odds.consensus) {
                oddsSection.classList.remove('visible');
                return;
            }

            oddsSection.classList.add('visible');
            currentOdds = odds;

            const consensus = odds.consensus;
            // Get colors that are different enough to distinguish
            const { awayColor, homeColor } = getTeamColors(awayTeam, homeTeam);

            // Use city names if available, fallback to abbreviations
            const homeDisplay = homeCity || homeTeam;
            const awayDisplay = awayCity || awayTeam;

            // Update spread (show which team is favored)
            const spreadEl = document.getElementById('odds-spread');
            if (consensus.spread !== null && consensus.spread !== undefined) {
                const spreadVal = consensus.spread;
                const favoredDisplay = spreadVal < 0 ? homeDisplay : awayDisplay;
                const spreadDisplay = Math.abs(spreadVal);
                spreadEl.innerHTML = `<span class="team-abbrev">${favoredDisplay}</span> -${spreadDisplay}`;
            } else {
                spreadEl.textContent = '--';
            }

            // Update total
            const totalEl = document.getElementById('odds-total');
            totalEl.textContent = consensus.total ? `O/U ${consensus.total}` : '--';

            // Update moneylines (use city names)
            const awayMl = consensus.away_ml;
            const homeMl = consensus.home_ml;
            document.getElementById('ml-away-abbrev').textContent = awayDisplay;
            document.getElementById('ml-home-abbrev').textContent = homeDisplay;

            const awayMlEl = document.getElementById('ml-away-value');
            const homeMlEl = document.getElementById('ml-home-value');
            awayMlEl.textContent = formatMoneyline(awayMl);
            homeMlEl.textContent = formatMoneyline(homeMl);

            // Style favorite vs underdog
            if (awayMl !== null && homeMl !== null) {
                awayMlEl.className = 'ml-value ' + (awayMl < homeMl ? 'favorite' : 'underdog');
                homeMlEl.className = 'ml-value ' + (homeMl < awayMl ? 'favorite' : 'underdog');
            }

            // Pre-Game Odds: Use fixedPreGameOdds from server (captured once, never changes)
            // This shows the opening line before any in-game movement
            if (!preGameOddsLocked) {
                // Use server-provided pre_game_odds if available, otherwise use current odds
                const preGameConsensus = fixedPreGameOdds || consensus;
                preGameOdds = { consensus: preGameConsensus };
                preGameOddsLocked = true;

                // Update probability display with team colors (only on first load)
                const homeProb = preGameConsensus.home_prob || 50;
                const awayProb = preGameConsensus.away_prob || 50;

                // Normalize to 100% total (remove vig)
                const totalProb = homeProb + awayProb;
                const normalizedHomeProb = Math.round((homeProb / totalProb) * 100);
                const normalizedAwayProb = 100 - normalizedHomeProb;

                // Update probability bar with team colors and proper text contrast
                const awayBar = document.getElementById('away-prob-bar');
                const homeBar = document.getElementById('home-prob-bar');

                awayBar.style.width = `${normalizedAwayProb}%`;
                awayBar.style.background = awayColor;
                awayBar.style.color = isColorDark(awayColor) ? '#ffffff' : '#0d1117';
                awayBar.textContent = normalizedAwayProb >= 20 ? `${normalizedAwayProb}%` : '';

                homeBar.style.width = `${normalizedHomeProb}%`;
                homeBar.style.background = homeColor;
                homeBar.style.color = isColorDark(homeColor) ? '#ffffff' : '#0d1117';
                homeBar.textContent = normalizedHomeProb >= 20 ? `${normalizedHomeProb}%` : '';

                // Update labels with team colors (use city names)
                document.getElementById('away-dot').style.background = awayColor;
                document.getElementById('home-dot').style.background = homeColor;
                document.getElementById('away-prob-text').textContent = `${awayDisplay} ${normalizedAwayProb}%`;
                document.getElementById('home-prob-text').textContent = `${homeDisplay} ${normalizedHomeProb}%`;
            }

            // Update vendor count
            document.getElementById('odds-vendor-count').textContent =
                consensus.vendor_count ? `Consensus from ${consensus.vendor_count} bookmakers` : '';
        }

        // Track active filters (all active by default)
        let activeFilters = new Set(['play_by_play', 'stats_nerd', 'hype_man', 'historian', 'ai_commentator']);

        function toggleFilter(botType) {
            if (activeFilters.has(botType)) {
                activeFilters.delete(botType);
            } else {
                activeFilters.add(botType);
            }
            applyFilters();
        }

        function applyFilters() {
            // Update button states
            document.querySelectorAll('.filter-btn').forEach(btn => {
                const bot = btn.dataset.bot;
                btn.classList.toggle('active', activeFilters.has(bot));
            });

            // Filter existing messages
            document.querySelectorAll('.chat-message').forEach(msg => {
                const botType = Array.from(msg.classList)
                    .find(c => c.startsWith('bot-'))
                    ?.replace('bot-', '');
                if (botType) {
                    msg.classList.toggle('filtered', !activeFilters.has(botType));
                }
            });
        }

        // Render quarter-by-quarter scores
        function renderQuarterScores(homePeriods, awayPeriods, homeTeam, awayTeam, homeTotal, awayTotal, currentPeriod) {
            const container = document.getElementById('quarter-scores');
            const tbody = document.getElementById('quarter-scores-body');
            if (!homePeriods || !awayPeriods || homePeriods.length === 0) {
                container.style.display = 'none';
                return;
            }

            // Show the quarter scores section
            container.style.display = 'block';

            // Check if there's overtime (more than 4 periods)
            const hasOT = homePeriods.length > 4 || awayPeriods.length > 4;

            // Show/hide OT columns in header
            document.querySelectorAll('.ot-col').forEach(el => {
                el.style.display = hasOT ? '' : 'none';
            });

            // Helper to get score for a period (0 if not played yet)
            const getScore = (periods, periodNum) => {
                const p = periods.find(p => p.period === periodNum);
                return p ? p.score : 0;
            };

            // Get all quarter scores
            const awayQ1 = getScore(awayPeriods, 1);
            const awayQ2 = getScore(awayPeriods, 2);
            const awayQ3 = getScore(awayPeriods, 3);
            const awayQ4 = getScore(awayPeriods, 4);
            const awayOT = hasOT ? awayPeriods.filter(p => p.period > 4).reduce((sum, p) => sum + p.score, 0) : 0;

            const homeQ1 = getScore(homePeriods, 1);
            const homeQ2 = getScore(homePeriods, 2);
            const homeQ3 = getScore(homePeriods, 3);
            const homeQ4 = getScore(homePeriods, 4);
            const homeOT = hasOT ? homePeriods.filter(p => p.period > 4).reduce((sum, p) => sum + p.score, 0) : 0;

            // Determine quarter winners (only for completed quarters)
            const q1AwayWins = awayQ1 > homeQ1 && currentPeriod > 1;
            const q1HomeWins = homeQ1 > awayQ1 && currentPeriod > 1;
            const q2AwayWins = awayQ2 > homeQ2 && currentPeriod > 2;
            const q2HomeWins = homeQ2 > awayQ2 && currentPeriod > 2;
            const q3AwayWins = awayQ3 > homeQ3 && currentPeriod > 3;
            const q3HomeWins = homeQ3 > awayQ3 && currentPeriod > 3;
            const q4AwayWins = awayQ4 > homeQ4 && (currentPeriod > 4 || (currentPeriod === 4 && awayQ4 > 0 && homeQ4 > 0));
            const q4HomeWins = homeQ4 > awayQ4 && (currentPeriod > 4 || (currentPeriod === 4 && awayQ4 > 0 && homeQ4 > 0));

            // Helper to get class for a quarter cell
            // For current quarter: only highlight the leading score (current-winner)
            // For completed quarters: highlight the winner (quarter-winner)
            const getQClass = (score, oppScore, isWinner, isCurrent) => {
                if (isCurrent) {
                    // In current quarter, only highlight if this team is winning the quarter
                    return score > oppScore ? 'current-winner' : 'current-quarter';
                }
                if (isWinner) return 'quarter-winner';
                return '';
            };

            const awayWinner = awayTotal > homeTotal ? 'winner' : '';
            const homeWinner = homeTotal > awayTotal ? 'winner' : '';

            // Build rows
            let html = '';

            // Away team row
            html += `<tr class="${awayWinner}">
                <td>${awayTeam}</td>
                <td class="${getQClass(awayQ1, homeQ1, q1AwayWins, currentPeriod === 1)}">${awayQ1 || '-'}</td>
                <td class="${getQClass(awayQ2, homeQ2, q2AwayWins, currentPeriod === 2)}">${awayQ2 || '-'}</td>
                <td class="${getQClass(awayQ3, homeQ3, q3AwayWins, currentPeriod === 3)}">${awayQ3 || '-'}</td>
                <td class="${getQClass(awayQ4, homeQ4, q4AwayWins, currentPeriod === 4)}">${awayQ4 || '-'}</td>
                ${hasOT ? `<td class="ot-col ${awayOT > homeOT && currentPeriod > 4 ? 'current-winner' : (currentPeriod > 4 ? 'current-quarter' : '')}">${awayOT || '-'}</td>` : ''}
                <td class="total-col">${awayTotal}</td>
            </tr>`;

            // Home team row
            html += `<tr class="${homeWinner}">
                <td>${homeTeam}</td>
                <td class="${getQClass(homeQ1, awayQ1, q1HomeWins, currentPeriod === 1)}">${homeQ1 || '-'}</td>
                <td class="${getQClass(homeQ2, awayQ2, q2HomeWins, currentPeriod === 2)}">${homeQ2 || '-'}</td>
                <td class="${getQClass(homeQ3, awayQ3, q3HomeWins, currentPeriod === 3)}">${homeQ3 || '-'}</td>
                <td class="${getQClass(homeQ4, awayQ4, q4HomeWins, currentPeriod === 4)}">${homeQ4 || '-'}</td>
                ${hasOT ? `<td class="ot-col ${homeOT > awayOT && currentPeriod > 4 ? 'current-winner' : (currentPeriod > 4 ? 'current-quarter' : '')}">${homeOT || '-'}</td>` : ''}
                <td class="total-col">${homeTotal}</td>
            </tr>`;

            tbody.innerHTML = html;
        }

        // Update box score display
        function updateBoxScore(stats) {
            playerStats = stats || { home: [], away: [] };

            // Update toggle button labels with team names
            document.getElementById('toggle-away').textContent = currentAwayTeam;
            document.getElementById('toggle-home').textContent = currentHomeTeam;

            // Show box score section if we have any stats
            const hasStats = playerStats.home.length > 0 || playerStats.away.length > 0;
            document.getElementById('box-score-section').classList.toggle('visible', hasStats);

            // Render current team's stats
            renderPlayerStats(currentStatsTeam);
        }

        function renderPlayerStats(team) {
            const players = playerStats[team] || [];
            const tbody = document.getElementById('player-stats-body');

            if (players.length === 0) {
                tbody.innerHTML = '<tr><td colspan="21" style="text-align: center; padding: 20px; color: var(--text-muted);">No player stats yet</td></tr>';
                return;
            }

            // Separate starters and bench
            const starters = players.filter(p => p.starter === true);
            const bench = players.filter(p => p.starter !== true);

            // Sort each group by points descending
            starters.sort((a, b) => (b.pts || 0) - (a.pts || 0));
            bench.sort((a, b) => (b.pts || 0) - (a.pts || 0));

            // Calculate totals
            const totals = { pts: 0, reb: 0, ast: 0, stl: 0, blk: 0, tov: 0, pf: 0, fgm: 0, fga: 0, fg3m: 0, fg3a: 0, ftm: 0, fta: 0, oreb: 0, dreb: 0 };

            // Helper to render a player row
            function renderPlayerRow(p) {
                const fgPct = p.fga > 0 ? (p.fgm / p.fga * 100).toFixed(1) : '-';
                const fg3Pct = p.fg3a > 0 ? (p.fg3m / p.fg3a * 100).toFixed(1) : '-';
                const ftPct = p.fta > 0 ? (p.ftm / p.fta * 100).toFixed(1) : '-';
                const ptsClass = p.pts >= 20 ? 'highlight' : '';
                const plusMinus = p.plus_minus !== undefined ? (p.plus_minus > 0 ? `+${p.plus_minus}` : p.plus_minus) : '-';
                const plusMinusClass = p.plus_minus > 0 ? 'positive' : (p.plus_minus < 0 ? 'negative' : '');

                // Check if player is on court (team variable is from parent scope)
                const isOnCourt = isPlayerOnCourt(p.name, team);
                const onCourtClass = isOnCourt ? 'active' : '';

                // Add to totals
                totals.pts += p.pts || 0;
                totals.reb += p.reb || 0;
                totals.ast += p.ast || 0;
                totals.stl += p.stl || 0;
                totals.blk += p.blk || 0;
                totals.tov += p.tov || 0;
                totals.pf += p.pf || 0;
                totals.fgm += p.fgm || 0;
                totals.fga += p.fga || 0;
                totals.fg3m += p.fg3m || 0;
                totals.fg3a += p.fg3a || 0;
                totals.ftm += p.ftm || 0;
                totals.fta += p.fta || 0;
                totals.oreb += p.oreb || 0;
                totals.dreb += p.dreb || 0;

                return `<tr>
                    <td class="player-col"><span class="on-court-dot ${onCourtClass}"></span>${p.name}</td>
                    <td>${p.min || '-'}</td>
                    <td class="${ptsClass}">${p.pts}</td>
                    <td>${p.reb}</td>
                    <td>${p.ast}</td>
                    <td>${p.stl}</td>
                    <td>${p.blk}</td>
                    <td>${p.fgm}</td>
                    <td>${p.fga}</td>
                    <td class="pct">${fgPct}</td>
                    <td>${p.fg3m}</td>
                    <td>${p.fg3a || 0}</td>
                    <td class="pct">${fg3Pct}</td>
                    <td>${p.ftm}</td>
                    <td>${p.fta}</td>
                    <td class="pct">${ftPct}</td>
                    <td>${p.oreb || 0}</td>
                    <td>${p.dreb || 0}</td>
                    <td>${p.tov || 0}</td>
                    <td>${p.pf || 0}</td>
                    <td class="${plusMinusClass}">${plusMinus}</td>
                </tr>`;
            }

            let html = '';

            // Starters section
            if (starters.length > 0) {
                html += `<tr class="section-header"><td colspan="21">Starters</td></tr>`;
                starters.forEach(p => { html += renderPlayerRow(p); });
            }

            // Bench section
            if (bench.length > 0) {
                html += `<tr class="section-header"><td colspan="21">Bench</td></tr>`;
                bench.forEach(p => { html += renderPlayerRow(p); });
            }

            // Add totals row
            const totalFgPct = totals.fga > 0 ? (totals.fgm / totals.fga * 100).toFixed(1) : '-';
            const totalFg3Pct = totals.fg3a > 0 ? (totals.fg3m / totals.fg3a * 100).toFixed(1) : '-';
            const totalFtPct = totals.fta > 0 ? (totals.ftm / totals.fta * 100).toFixed(1) : '-';
            html += `<tr class="totals-row">
                <td class="player-col">TOTAL</td>
                <td>-</td>
                <td>${totals.pts}</td>
                <td>${totals.reb}</td>
                <td>${totals.ast}</td>
                <td>${totals.stl}</td>
                <td>${totals.blk}</td>
                <td>${totals.fgm}</td>
                <td>${totals.fga}</td>
                <td class="pct">${totalFgPct}</td>
                <td>${totals.fg3m}</td>
                <td>${totals.fg3a}</td>
                <td class="pct">${totalFg3Pct}</td>
                <td>${totals.ftm}</td>
                <td>${totals.fta}</td>
                <td class="pct">${totalFtPct}</td>
                <td>${totals.oreb}</td>
                <td>${totals.dreb}</td>
                <td>${totals.tov}</td>
                <td>${totals.pf}</td>
                <td>-</td>
            </tr>`;

            tbody.innerHTML = html;
        }

        function switchTeamStats(team) {
            currentStatsTeam = team;

            // Update toggle buttons
            document.getElementById('toggle-away').classList.toggle('active', team === 'away');
            document.getElementById('toggle-home').classList.toggle('active', team === 'home');

            // Re-render stats
            renderPlayerStats(team);
        }

        // Extract player name from a message text
        function extractPlayerFromMessage(text) {
            if (!text) return null;

            // Common patterns in play-by-play messages
            // "Player Name (TEAM) hits..." or "Player Name (TEAM) makes..."
            const patterns = [
                /^[üí•‚úìüö´üëãüí®üö®‚≠êüî•]+\s*([A-Z][a-z']+(?:\s+[A-Z][a-z']+)+)\s*\(/i,  // Emoji + name + (
                /POSTER!\s*([A-Z][a-z']+(?:\s+[A-Z][a-z']+)+)/i,  // POSTER! name
                /by\s+([A-Z][a-z']+(?:\s+[A-Z][a-z']+)+)/i,  // "by Name"
                /on\s+([A-Z][a-z']+(?:\s+[A-Z][a-z']+)+)\s*\(/i,  // "on Name ("
            ];

            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    return match[1].trim();
                }
            }
            return null;
        }

        // Track a player mention from a play
        function trackPlayerMention(playerName, teamAbbrev) {
            if (!playerName || !teamAbbrev) return;

            // Determine if home or away
            const isHome = teamAbbrev === currentHomeTeam;
            const teamKey = isHome ? 'home' : 'away';

            // Add to recent plays
            recentPlayPlayers.push({
                player: playerName,
                team: teamKey,
                timestamp: Date.now()
            });

            // Keep only recent plays
            if (recentPlayPlayers.length > RECENT_PLAYS_WINDOW * 2) {
                recentPlayPlayers = recentPlayPlayers.slice(-RECENT_PLAYS_WINDOW * 2);
            }

            // Update on-court sets from recent plays
            updateOnCourtFromRecentPlays();
        }

        // Update on-court player sets based on recent play mentions
        function updateOnCourtFromRecentPlays() {
            // Clear current sets
            onCourtPlayers.home.clear();
            onCourtPlayers.away.clear();

            // Get players from most recent plays
            const recentPlays = recentPlayPlayers.slice(-RECENT_PLAYS_WINDOW);

            for (const play of recentPlays) {
                onCourtPlayers[play.team].add(play.player);
            }
        }

        // Check if a player name matches any on-court player (fuzzy match for last name)
        function isPlayerOnCourt(playerName, teamKey) {
            const onCourt = onCourtPlayers[teamKey];
            if (!onCourt || onCourt.size === 0) return false;

            // Exact match
            if (onCourt.has(playerName)) return true;

            // Last name match (for when play shows "Smith" but roster shows "John Smith")
            const lastName = playerName.split(' ').pop();
            for (const name of onCourt) {
                if (name.includes(lastName) || lastName.includes(name.split(' ').pop())) {
                    return true;
                }
            }
            return false;
        }

        // Process incoming messages to track on-court players
        function processMessagesForOnCourt(messages) {
            if (!messages || !Array.isArray(messages)) return;

            for (const msg of messages) {
                // Only process play-by-play type messages
                if (msg.bot === 'play_by_play' || msg.bot === 'hype_man' || msg.bot === 'referee') {
                    const playerName = extractPlayerFromMessage(msg.text);
                    if (playerName && msg.team) {
                        trackPlayerMention(playerName, msg.team);
                    }
                }
            }
        }

        // Format UTC time to local time
        function formatLocalTime(utcTimeStr) {
            if (!utcTimeStr) return null;
            try {
                const date = new Date(utcTimeStr);
                return date.toLocaleTimeString([], {
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                });
            } catch (e) {
                return null;
            }
        }

        // Get game status text with local time
        function getGameStatusText(game) {
            // For live or finished games, use the status as-is
            if (game.status === 'Final' || game.status === 'Final (Saved)' ||
                game.status.includes('Q') || game.status === 'Half' ||
                game.status.includes('OT')) {
                return game.status;
            }

            // For upcoming games, check if it's about to start (within 30 minutes)
            if (game.game_time_utc) {
                try {
                    const gameTime = new Date(game.game_time_utc);
                    const now = new Date();
                    const minutesUntilGame = (gameTime - now) / 60000;

                    // If within 30 minutes of start or just past start time, show "Pregame"
                    if (minutesUntilGame <= 30 && minutesUntilGame > -10) {
                        const localTime = formatLocalTime(game.game_time_utc);
                        return `Pregame (${localTime})`;
                    }
                } catch (e) {
                    // Ignore parsing errors
                }
            }

            // Check if status is an ISO timestamp (from BallDontLie API)
            if (game.status && game.status.includes('T') && game.status.includes('Z')) {
                try {
                    const gameTime = new Date(game.status);
                    const localTime = gameTime.toLocaleTimeString('en-US', {
                        hour: 'numeric',
                        minute: '2-digit',
                        hour12: true
                    });
                    return localTime;
                } catch (e) {
                    // Ignore parsing errors
                }
            }

            // For upcoming games, convert to local time
            const localTime = formatLocalTime(game.game_time_utc);
            if (localTime) {
                return localTime;
            }

            // Fallback to original status
            return game.status;
        }

        async function loadGames() {
            try {
                // Only fetch today's games for faster loading
                const response = await fetch('/api/beta-live/games?today_only=true');
                const data = await response.json();

                const select = document.getElementById('game-select');
                select.innerHTML = '<option value="">-- Select a game --</option>';

                // Reset games data store
                gamesData = {};

                if (data.games && data.games.length > 0) {
                    // Sort games: Live first, then upcoming, then final
                    const getGameOrder = (game) => {
                        if (game.status.includes('Q') || game.status === 'Half' || game.status.includes('OT')) return 0;  // Live
                        if (game.status === 'Final' || game.status === 'Final (Saved)') return 2;  // Final
                        return 1;  // Upcoming
                    };

                    data.games.sort((a, b) => getGameOrder(a) - getGameOrder(b));

                    // Add all games directly (no optgroups needed for today only)
                    data.games.forEach(game => {
                        // Store game data for later access
                        gamesData[game.game_id] = game;

                        const option = document.createElement('option');
                        option.value = game.game_id;
                        const statusText = getGameStatusText(game);

                        // Build team names - use abbreviation as fallback
                        let awayFull = game.away_team_city && game.away_team_name
                            ? `${game.away_team_city} ${game.away_team_name}`.trim()
                            : game.away_team;
                        let homeFull = game.home_team_city && game.home_team_name
                            ? `${game.home_team_city} ${game.home_team_name}`.trim()
                            : game.home_team;

                        let text = `${awayFull} @ ${homeFull} - ${statusText}`;
                        if (game.status.includes('Q') || game.status === 'Half' || game.status.includes('OT')) {
                            text += ` (${game.away_score}-${game.home_score})`;
                        } else if (game.status === 'Final' || game.status === 'Final (Saved)') {
                            text += ` (${game.away_score}-${game.home_score})`;
                        }
                        // Add history indicator
                        if (game.has_history) {
                            text += ' üìú';
                        }
                        option.textContent = text;
                        select.appendChild(option);
                    });
                } else {
                    select.innerHTML = '<option value="">No games today</option>';
                }

                // Check URL for game parameter and auto-select
                const urlParams = new URLSearchParams(window.location.search);
                const gameFromUrl = urlParams.get('game');
                if (gameFromUrl && gamesData[gameFromUrl]) {
                    select.value = gameFromUrl;
                    selectGame(gameFromUrl, false);  // Don't update URL again
                }
            } catch (error) {
                console.error('Error loading games:', error);
                document.getElementById('game-select').innerHTML = '<option value="">Error loading games</option>';
            }
        }

        function selectGame(gameId, updateUrl = true) {
            if (!gameId) {
                document.getElementById('scoreboard').style.display = 'none';
                document.getElementById('chat-container').style.display = 'none';
                document.getElementById('mini-charts').classList.remove('visible');
                document.getElementById('odds-section').classList.remove('visible');
                document.getElementById('quarter-scores').style.display = 'none';
                if (pollInterval) {
                    clearInterval(pollInterval);
                    pollInterval = null;
                }
                // Clear URL parameter
                if (updateUrl) {
                    window.history.replaceState({}, '', '/beta-live');
                }
                return;
            }

            // If same game already selected, don't reset everything
            const isSameGame = currentGameId === gameId;

            if (!isSameGame) {
                currentGameId = gameId;

                // Reset pre-game odds only when switching games
                preGameOdds = null;
                preGameOddsLocked = false;
                lastActionNumber = 0;
                scoreHistoryLoaded = false;  // Reset history loaded flag

                // Reset history loading state
                hasMoreHistory = false;
                historyCutoffAction = 0;
                isLoadingFullHistory = false;
                const loadMoreEl = document.getElementById('load-more-container');
                if (loadMoreEl) loadMoreEl.style.display = 'none';

                // Reset delay buffer when switching games
                if (DELAY_FEATURE_ENABLED) {
                    delayBuffer = [];
                    document.getElementById('delay-select').value = '0';
                    delaySeconds = 0;
                    document.getElementById('delay-indicator').classList.remove('active');
                    if (delayDisplayInterval) {
                        clearInterval(delayDisplayInterval);
                        delayDisplayInterval = null;
                    }
                }

                // Reset countdown timer when switching games
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                }
                scheduledTimeUtc = null;
                gameHasStarted = false;

                // Reset on-court player tracking
                onCourtPlayers = { home: new Set(), away: new Set() };
                recentPlayPlayers = [];

                // Hide odds section until new game's odds load
                document.getElementById('odds-section').classList.remove('visible');

                // Clear chart data for new game (including elapsed time arrays)
                chartData = {
                    labels: [],
                    elapsed: [],
                    clocks: [],
                    homeScores: [],
                    awayScores: [],
                    leadDiffs: [],
                    homeProbs: [],
                    quarterMarkers: [],
                    quarterLabels: []
                };
            }

            // Update URL with game ID (allows refresh and sharing)
            if (updateUrl) {
                window.history.replaceState({}, '', `/beta-live?game=${gameId}`);
            }

            // Show UI elements immediately
            document.getElementById('scoreboard').style.display = 'flex';
            document.getElementById('chat-container').style.display = 'block';

            // Get game data from stored games
            const gameData = gamesData[gameId];

            // Update scoreboard immediately from stored data (no waiting for API)
            if (gameData) {
                // Show city names in scoreboard
                document.getElementById('home-team').textContent = gameData.home_team_city || gameData.home_team;
                document.getElementById('away-team').textContent = gameData.away_team_city || gameData.away_team;
                document.getElementById('home-score').textContent = gameData.home_score || 0;
                document.getElementById('away-score').textContent = gameData.away_score || 0;

                // Set team logos
                document.getElementById('home-logo').src = getTeamLogoUrl(gameData.home_team);
                document.getElementById('away-logo').src = getTeamLogoUrl(gameData.away_team);

                // Show initial status from games data (will be updated by feed)
                const clockSection = document.getElementById('game-clock-section');
                if (gameData.status && gameData.status !== '--') {
                    clockSection.style.display = 'block';
                    // Parse status like "Q3 2:00" or "Half" or "Final"
                    if (gameData.status.includes('Q') || gameData.status === 'Half') {
                        const parts = gameData.status.split(' ');
                        document.getElementById('game-quarter').textContent = parts[0] || '';
                        document.getElementById('game-clock').textContent = parts[1] || '';
                    } else if (gameData.status === 'Final' || gameData.status === 'Final (Saved)') {
                        document.getElementById('game-quarter').textContent = 'FINAL';
                        document.getElementById('game-clock').textContent = '';
                    } else {
                        document.getElementById('game-quarter').textContent = 'PRE-GAME';
                        document.getElementById('game-clock').textContent = '';
                    }
                }

                // Set team names for chart labels (use abbreviations for compactness)
                currentHomeTeam = gameData.home_team || 'HOME';
                currentAwayTeam = gameData.away_team || 'AWAY';

                // Display odds if available (pass both abbrev and city for display flexibility)
                // Pass pre_game_odds separately so it's fixed and never changes
                if (gameData.odds) {
                    updateOddsDisplay(gameData.odds, gameData.home_team, gameData.away_team, gameData.home_team_city, gameData.away_team_city, gameData.pre_game_odds);
                } else {
                    document.getElementById('odds-section').classList.remove('visible');
                }
            }

            // Only reinitialize charts for a new game
            if (!isSameGame) {
                // Clear chat feed for new game (preserve load-more-container structure)
                const chatFeed = document.getElementById('chat-feed');
                chatFeed.innerHTML = `
                    <div class="load-more-container" id="load-more-container" style="display: none;">
                        <button class="load-more-btn" id="load-more-btn">
                            <span class="load-more-icon">‚èÆ</span>
                            Load Full Game History
                        </button>
                        <span class="load-more-hint">Showing recent plays only</span>
                    </div>
                    <div class="loading" id="loading"><div class="spinner"></div><p>Loading game feed...</p></div>
                `;

                // Clear quarter scores and box score from previous game
                document.getElementById('quarter-scores').style.display = 'none';
                document.getElementById('quarter-scores-body').innerHTML = '';
                document.getElementById('box-score-section').classList.remove('visible');

                // Initialize charts (will use currentHomeTeam/currentAwayTeam for labels)
                initCharts();

                // Show delay selector for live games only (not pregame, not final, not historical)
                if (DELAY_FEATURE_ENABLED && gameData) {
                    const isLiveGame = gameData.status &&
                        (gameData.status.includes('Q') || gameData.status === 'Half') &&
                        !gameData.status.includes('Final');
                    document.getElementById('delay-selector').style.display = isLiveGame ? 'flex' : 'none';
                } else {
                    document.getElementById('delay-selector').style.display = 'none';
                }

                // Only add initial 0-0 chart points for PRE-GAME games (not yet started)
                // This allows the chart to show pre-game odds before any scoring
                // For live/completed games, score history from the API will populate the chart
                const isPreGame = !gameData || !gameData.status ||
                    (!gameData.status.includes('Q') &&
                     gameData.status !== 'Half' &&
                     !gameData.status.includes('Final'));
                if (isPreGame && preGameOddsLocked) {
                    // Add 0-0 starting point for pre-game display (elapsed=0 for game start)
                    updateCharts(0, 0, currentHomeTeam, currentAwayTeam, null, 1, 0, '12:00');
                }

                // Start polling for new game
                fetchFeed();
                if (pollInterval) clearInterval(pollInterval);
                pollInterval = setInterval(fetchFeed, 5000); // Poll every 5 seconds
            }
        }

        async function fetchFeed() {
            if (!currentGameId) return;

            // Capture game ID at request time to detect stale responses
            const requestGameId = currentGameId;

            try {
                const response = await fetch(`/api/beta-live/feed/${requestGameId}?last_action=${lastActionNumber}&client_id=${clientId}`);
                const data = await response.json();

                // Ignore stale responses if game changed while request was in flight
                if (currentGameId !== requestGameId) {
                    console.log('Ignoring stale response for game:', requestGameId);
                    return;
                }

                // If delay is enabled and this is live data, buffer it
                // Historical/pregame/final games should display immediately
                if (DELAY_FEATURE_ENABLED && delaySeconds > 0 && !data.is_historical && !data.is_pregame && data.status !== 'Final') {
                    delayBuffer.push({
                        data: data,
                        receivedAt: Date.now()
                    });
                    // Start display interval if not running
                    if (!delayDisplayInterval) {
                        delayDisplayInterval = setInterval(processDelayBuffer, 500);
                    }
                } else {
                    // No delay or non-live data - display immediately
                    displayFeedData(data, false);
                }

            } catch (error) {
                console.error('Error fetching feed:', error);
            }
        }

        function startCountdownTimer() {
            // Clear any existing countdown
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }

            function updateCountdown() {
                if (!scheduledTimeUtc || gameHasStarted) {
                    if (countdownInterval) {
                        clearInterval(countdownInterval);
                        countdownInterval = null;
                    }
                    return;
                }

                const now = Date.now();
                const diff = scheduledTimeUtc - now;
                const clockEl = document.getElementById('game-clock');
                const quarterEl = document.getElementById('game-quarter');

                if (diff <= 0) {
                    // Scheduled time has passed - show "STARTING SOON"
                    quarterEl.textContent = 'STARTING';
                    clockEl.textContent = 'SOON';
                } else {
                    // Calculate hours, minutes, seconds
                    const hours = Math.floor(diff / (1000 * 60 * 60));
                    const mins = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                    const secs = Math.floor((diff % (1000 * 60)) / 1000);

                    if (hours > 0) {
                        clockEl.textContent = `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                    } else {
                        clockEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                    }
                    quarterEl.textContent = 'TIPOFF IN';
                }
            }

            // Update immediately and then every second
            updateCountdown();
            countdownInterval = setInterval(updateCountdown, 1000);
        }

        function stopCountdownTimer() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            gameHasStarted = true;
        }

        function createMessageElement(msg) {
            const div = document.createElement('div');
            div.className = `chat-message bot-${msg.bot}`;
            if (msg.team) div.classList.add(`team-${msg.team}`);

            // Apply filter immediately if this bot is filtered out
            if (!activeFilters.has(msg.bot)) {
                div.classList.add('filtered');
            }

            const emoji = botEmojis[msg.bot] || '&#x1F4AC;';
            const botName = botNames[msg.bot] || msg.bot;
            // Show "PRE-GAME" for pregame messages (negative action numbers), otherwise show quarter/clock
            const time = (msg.action_number < 0) ? 'PRE-GAME' : (msg.clock ? `Q${msg.period} ${msg.clock}` : '');

            div.innerHTML = `
                <div class="msg-avatar">${emoji}</div>
                <div class="msg-content">
                    <div class="msg-header">
                        <span class="msg-bot-name bot-${msg.bot}">${botName}</span>
                        <span class="msg-time">${time}</span>
                    </div>
                    <div class="msg-text">${msg.text}</div>
                    <div class="msg-score">${msg.score}</div>
                </div>
            `;

            return div;
        }

        // Initialize
        document.getElementById('game-select').addEventListener('change', (e) => {
            selectGame(e.target.value);
        });

        // Delay selector event handler
        if (DELAY_FEATURE_ENABLED) {
            document.getElementById('delay-select').addEventListener('change', (e) => {
                delaySeconds = parseInt(e.target.value) || 0;
                const indicator = document.getElementById('delay-indicator');

                if (delaySeconds > 0) {
                    indicator.classList.add('active');
                    // Start the display interval if not already running
                    if (!delayDisplayInterval) {
                        delayDisplayInterval = setInterval(processDelayBuffer, 500);
                    }
                } else {
                    indicator.classList.remove('active');
                    // Stop the display interval and flush buffer immediately
                    if (delayDisplayInterval) {
                        clearInterval(delayDisplayInterval);
                        delayDisplayInterval = null;
                    }
                    flushDelayBuffer();
                }
            });
        }

        // Process delayed buffer - displays items that are old enough
        function processDelayBuffer() {
            if (!DELAY_FEATURE_ENABLED || delaySeconds === 0 || delayBuffer.length === 0) return;

            const now = Date.now();
            const delayMs = delaySeconds * 1000;
            let itemsToDisplay = [];

            // Find all items old enough to display
            while (delayBuffer.length > 0 && (now - delayBuffer[0].receivedAt) >= delayMs) {
                itemsToDisplay.push(delayBuffer.shift());
            }

            // Display the delayed items
            itemsToDisplay.forEach(item => {
                displayFeedData(item.data, true);  // true = is delayed display
            });

            // Update delay countdown
            if (delayBuffer.length > 0) {
                const oldestWait = Math.ceil((delayMs - (now - delayBuffer[0].receivedAt)) / 1000);
                document.getElementById('delay-countdown').textContent = `${oldestWait}s`;
            } else {
                document.getElementById('delay-countdown').textContent = `${delaySeconds}s`;
            }
        }

        // Flush all buffered data immediately (when delay is disabled)
        function flushDelayBuffer() {
            while (delayBuffer.length > 0) {
                const item = delayBuffer.shift();
                displayFeedData(item.data, false);
            }
        }

        // Display feed data (separated from fetch for delay support)
        function displayFeedData(data, isDelayed = false) {
            if (data.error) {
                console.error('Feed error:', data.error);
                return;
            }

            // Check if this is historical data (completed game)
            if (data.is_historical && !isDelayed) {
                // Stop polling for completed games
                if (pollInterval) {
                    clearInterval(pollInterval);
                    pollInterval = null;
                }
            }

            // Update scoreboard (use city names from stored game data)
            const storedGame = gamesData[currentGameId];
            const homeCity = storedGame?.home_team_city || data.game_info?.home_team;
            const awayCity = storedGame?.away_team_city || data.game_info?.away_team;

            if (data.game_info) {
                document.getElementById('home-team').textContent = homeCity;
                document.getElementById('away-team').textContent = awayCity;
            }

            // Update game clock, quarter, timeouts, and bonus indicators
            const isGameLive = data.period > 0 && data.status !== 'Final';
            const clockSection = document.getElementById('game-clock-section');

            // Stop countdown timer when game actually starts (tipoff detected)
            if (isGameLive && !gameHasStarted) {
                stopCountdownTimer();
            }

            // Show/hide delay selector based on live status
            if (DELAY_FEATURE_ENABLED) {
                const delaySel = document.getElementById('delay-selector');
                if (isGameLive && !data.is_pregame) {
                    delaySel.style.display = 'flex';
                } else {
                    delaySel.style.display = 'none';
                    // Clear delay when game ends
                    if (delaySeconds > 0) {
                        delaySeconds = 0;
                        document.getElementById('delay-select').value = '0';
                        document.getElementById('delay-indicator').classList.remove('active');
                        flushDelayBuffer();
                    }
                }
            }

            if (isGameLive && data.game_clock) {
                // Show game clock during live games
                clockSection.style.display = 'block';
                const periodText = data.period <= 4 ? `Q${data.period}` : `OT${data.period - 4}`;
                document.getElementById('game-quarter').textContent = periodText;
                document.getElementById('game-clock').textContent = data.game_clock;
                lastDisplayedClock = { period: data.period, clock: data.game_clock };
            } else if (data.status === 'Final') {
                // Show "FINAL" for completed games
                clockSection.style.display = 'block';
                document.getElementById('game-quarter').textContent = 'FINAL';
                document.getElementById('game-clock').textContent = '';
            } else if (data.is_pregame) {
                // Show countdown for upcoming games
                clockSection.style.display = 'block';
                document.getElementById('game-quarter').textContent = 'TIPOFF IN';

                // Store scheduled time and start countdown timer
                if (data.scheduled_time_utc && !countdownInterval) {
                    scheduledTimeUtc = data.scheduled_time_utc;
                    startCountdownTimer();
                }
            } else {
                // Hide clock section when no relevant status
                clockSection.style.display = 'none';
            }

            // Update timeouts (only show during live games)
            const awayTimeouts = document.getElementById('away-timeouts');
            const homeTimeouts = document.getElementById('home-timeouts');
            if (isGameLive) {
                awayTimeouts.style.display = 'flex';
                homeTimeouts.style.display = 'flex';
                renderTimeoutDots(awayTimeouts, data.away_timeouts ?? 7);
                renderTimeoutDots(homeTimeouts, data.home_timeouts ?? 7);
            } else {
                awayTimeouts.style.display = 'none';
                homeTimeouts.style.display = 'none';
            }

            // Update bonus indicators
            const awayBonus = document.getElementById('away-bonus');
            const homeBonus = document.getElementById('home-bonus');
            if (isGameLive) {
                awayBonus.classList.toggle('active', data.away_in_bonus || false);
                homeBonus.classList.toggle('active', data.home_in_bonus || false);
            } else {
                awayBonus.classList.remove('active');
                homeBonus.classList.remove('active');
            }

            if (data.score) {
                document.getElementById('home-score').textContent = data.score.home;
                document.getElementById('away-score').textContent = data.score.away;
                lastDisplayedScore = { home: data.score.home, away: data.score.away };

                // Update header score with city names
                let scoreText = `${awayCity} ${data.score.away} - ${homeCity} ${data.score.home}`;
                if (data.status === 'Final') {
                    scoreText += ' (FINAL)';
                } else if (data.is_pregame) {
                    scoreText = `${awayCity} @ ${homeCity} (PREGAME)`;
                }
                document.getElementById('stat-score').textContent = scoreText;

                // Handle chart updates (skip for delayed displays to avoid duplicates)
                if (!isDelayed) {
                    // Load score history for charts (only once per game)
                    if (!scoreHistoryLoaded && (data.is_historical || data.is_first_load) && data.scores && data.scores.length > 0) {
                        data.scores.forEach(s => {
                            updateCharts(s.home, s.away, data.game_info.home_team, data.game_info.away_team, null, s.period, s.elapsed, s.clock);
                        });
                        scoreHistoryLoaded = true;
                    } else if (!data.is_historical && !data.is_first_load) {
                        // Live update - calculate elapsed
                        const currentPeriod = data.period || null;
                        const gameClock = data.game_clock || null;
                        let elapsed = null;
                        if (gameClock && currentPeriod) {
                            const parts = gameClock.split(':');
                            if (parts.length === 2) {
                                const mins = parseInt(parts[0]) || 0;
                                const secs = parseInt(parts[1]) || 0;
                                const remaining = mins * 60 + secs;
                                const quarterElapsed = 720 - remaining;
                                elapsed = (currentPeriod - 1) * 720 + quarterElapsed;
                            }
                        }
                        updateCharts(data.score.home, data.score.away, data.game_info.home_team, data.game_info.away_team, null, currentPeriod, elapsed, gameClock);
                    }
                }
            }

            // Update box score with player stats
            if (data.player_stats) {
                updateBoxScore(data.player_stats);
            }

            // Update quarter-by-quarter scores
            if (data.home_periods && data.away_periods && data.score) {
                renderQuarterScores(
                    data.home_periods,
                    data.away_periods,
                    currentHomeTeam,
                    currentAwayTeam,
                    data.score.home,
                    data.score.away,
                    data.period || 0
                );
            }

            // Update stats in header
            document.getElementById('stat-lead-changes').textContent = `üîÑ ${data.lead_changes || 0}`;
            if (data.is_historical) {
                document.getElementById('stat-viewers').textContent = 'üì∫ Replay';
            } else if (data.is_pregame) {
                document.getElementById('stat-viewers').textContent = '‚è∞ Starting Soon';
            } else {
                document.getElementById('stat-viewers').textContent = `üëÅ ${data.viewer_count || 1}`;
            }

            // Update last action number (handle pregame with negative action numbers)
            if (data.last_action > lastActionNumber || (data.is_pregame && lastActionNumber === 0)) {
                lastActionNumber = data.last_action;
            }

            // Add new messages
            if (data.messages && data.messages.length > 0) {
                const feed = document.getElementById('chat-feed');
                const loading = document.getElementById('loading');
                if (loading) loading.remove();

                // Get existing action numbers to avoid duplicates
                const existingActionNumbers = new Set();
                feed.querySelectorAll('.chat-message').forEach(el => {
                    if (el.dataset.actionNumber) {
                        existingActionNumbers.add(String(el.dataset.actionNumber));
                    }
                });

                // Filter to only new messages (not already displayed)
                const newMessages = data.messages.filter(msg =>
                    !existingActionNumbers.has(String(msg.action_number))
                );

                if (newMessages.length > 0) {
                    newMessages.forEach(msg => {
                        const msgEl = createMessageElement(msg);
                        msgEl.dataset.actionNumber = msg.action_number;
                        feed.appendChild(msgEl);
                    });

                    // Track on-court players from messages
                    processMessagesForOnCourt(newMessages);

                    // Auto-scroll to bottom
                    feed.scrollTop = feed.scrollHeight;
                }
            }

            // Handle empty feed for completed games
            if (data.is_historical && (!data.messages || data.messages.length === 0)) {
                const feed = document.getElementById('chat-feed');
                const loading = document.getElementById('loading');
                if (loading) {
                    loading.innerHTML = '<p>No chat history available for this game.</p>';
                }
            }

            // Handle "Load More History" button visibility
            if (data.has_more_history && !isLoadingFullHistory) {
                hasMoreHistory = true;
                historyCutoffAction = data.history_cutoff_action || 0;
                const loadMoreEl = document.getElementById('load-more-container');
                if (loadMoreEl) loadMoreEl.style.display = 'flex';
            } else {
                hasMoreHistory = false;
                const loadMoreEl = document.getElementById('load-more-container');
                if (loadMoreEl) loadMoreEl.style.display = 'none';
            }
        }

        // Filter button click handlers
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                toggleFilter(btn.dataset.bot);
            });
        });

        // Team toggle button click handlers
        document.querySelectorAll('.team-toggle-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                switchTeamStats(btn.dataset.team);
            });
        });

        // Load Full History button click handler
        document.getElementById('load-more-btn').addEventListener('click', async () => {
            if (!currentGameId || isLoadingFullHistory) return;

            isLoadingFullHistory = true;
            const btn = document.getElementById('load-more-btn');
            const originalText = btn.innerHTML;
            btn.innerHTML = '<span class="load-more-icon">‚è≥</span> Loading...';
            btn.disabled = true;

            try {
                // Fetch full history (recent_only=false)
                const response = await fetch(`/api/beta-live/feed/${currentGameId}?last_action=0&client_id=${clientId}&recent_only=false`);
                const data = await response.json();

                if (data.messages && data.messages.length > 0) {
                    const feed = document.getElementById('chat-feed');
                    const loadMoreContainer = document.getElementById('load-more-container');

                    // Get existing messages to avoid duplicates
                    const existingMessages = feed.querySelectorAll('.chat-message');
                    const existingActionNumbers = new Set();
                    existingMessages.forEach(el => {
                        const actionNum = el.dataset.actionNumber;
                        if (actionNum) existingActionNumbers.add(actionNum);
                    });

                    // Filter to only older messages (before cutoff)
                    const olderMessages = data.messages.filter(msg =>
                        msg.action_number < historyCutoffAction &&
                        !existingActionNumbers.has(String(msg.action_number))
                    );

                    // Create message elements and collect them
                    const newElements = olderMessages.map(msg => {
                        const el = createMessageElement(msg);
                        el.dataset.actionNumber = msg.action_number;
                        return el;
                    });

                    // Insert older messages at the top (after load-more-container)
                    const insertPoint = loadMoreContainer.nextSibling;
                    newElements.forEach(el => {
                        feed.insertBefore(el, insertPoint);
                    });

                    console.log(`Loaded ${newElements.length} older messages`);
                }

                // Hide the button since we've loaded full history
                document.getElementById('load-more-container').style.display = 'none';
                hasMoreHistory = false;

            } catch (error) {
                console.error('Error loading full history:', error);
                btn.innerHTML = originalText;
                btn.disabled = false;
                isLoadingFullHistory = false;
            }
        });

        // Display user's timezone
        function getTimezoneAbbreviation() {
            const date = new Date();
            const timeStr = date.toLocaleTimeString('en-US', { timeZoneName: 'short' });
            // Extract timezone abbreviation (e.g., "MST", "EST", "PST")
            const match = timeStr.match(/[A-Z]{2,5}$/);
            return match ? match[0] : Intl.DateTimeFormat().resolvedOptions().timeZone;
        }
        document.getElementById('timezone-label').textContent = `(${getTimezoneAbbreviation()})`;

        loadGames();

        // Pre-warm caches in background for faster game switching
        // This fetches injuries and rosters for all teams playing today
        setTimeout(() => {
            fetch('/api/beta-live/prewarm').catch(() => {});
        }, 500);  // Delay slightly to prioritize initial page load

        // Refresh game list every 60 seconds
        setInterval(loadGames, 60000);
    </script>
</body>
</html>
